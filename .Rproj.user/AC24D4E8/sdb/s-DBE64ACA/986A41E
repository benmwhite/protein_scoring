{
    "contents" : "setwd(\"~/Dropbox/School/Research/Minkowski\")\nlibrary(\"ggplot2\")\nlibrary(\"reshape2\")\nlibrary(\"dplyr\")\nlibrary(\"stringr\")\n\n####Functions####\n#function for renaming columns in dfs\nrename_col <- function(data, oldname, newname) {\n  names(data)[names(data) == oldname] <- newname\n  return(data)\n}\n\napply_col <- function(data, colname, f, ...) {\n  data[[colname]] <- f(data[[colname]], ...)\n  return(data)\n}\n\n\n####Chen data####\ndata <- tbl_df(read.csv(\"Chen-mass.csv\", header = TRUE,\n               stringsAsFactors = FALSE))\n#cleaning protein name strings\ndata$Bait  <- str_trim(data$Bait)\ndata$Prey <- str_trim(data$Prey)\n\n\n\n\n\n#cleaning to make sure that each interaction has only\n#one occurence in the data set. Also removing bait interactions\n#with themselves\ndata <- data %.% \n  group_by(No, Bait, Prey) %.% \n  summarise(Count = sum(SpectraC)) %.%\n  filter(Bait != Prey) %.%\n  rename_col(\"No\", \"ExpNo\") %.%\n  ungroup()\n\n#######OLD#########\n#function for computing normalized minkowski distance-based poisson scores\n#takes data frame as input and returns data frame with results added\n#as a new columns\n\n#quick and dirty poisson scoring using minkowski distances from 0 divided by \n#number of experiments as baseline poisson\n#mean parameter. score is the quantile of the count from distribution.\n\ncompute_scores <- function(data, p) {\n  #data input must have \"ExpNo\", \"Prey\", and \"Count\" variables\n  #p is minkowski distance parameter\n  n_exp <- length(unique(data$ExpNo)) #total number of experiments\n  minkdists <- data %.%\n    group_by(Prey) %.%\n    summarise(MDist = (1/n_exp) * (sum(Count^p)^(1/p)))\n  scores <- inner_join(data, minkdists) %.%\n    group_by(Prey) %.%\n    mutate(Scores = ppois(Count, lambda = MDist)) %.%\n    ungroup()\n  return(scores)\n}\n\n#scores01 <- compute_scores(data, 0.1, \"Scores01\")\n#scores02 <- compute_scores(data, 0.2, \"Scores02\")\n#scores04 <- compute_scores(data, 0.4, \"Scores04\")\n#scores06 <- compute_scores(data, 0.6, \"Scores06\")\n#scores08 <- compute_scores(data, 0.8, \"Scores08\")\n\n#scores <- inner_join(scores01, scores02) %.%\n#  inner_join(scores04) %.%\n#  inner_join(scores06) %.%\n#  inner_join(scores08)\n\n#rm(scores01, scores02, scores04, scores06, scores08)\n#write.csv(scores, \"scores.csv\", row.names = FALSE)\n\n####Computing log minkowski distances from 0####\n#takes data frame as input, returns data frame with dists as new column\n#also computes d_i^k - d_i, where d_i^k is the minkowski distance\n#from 0 if x_ik is zer0. takes data frame input and returns data frame\n#with results as a new columns.\n\ncompute_dist <- function(data, p, logtrans = FALSE) {\n  #data input must have \"Prey\", and \"Count\" variables\n  #p is minkowski distance parameter\n  if (logtrans == TRUE) {\n    out <- data %.%\n      group_by(Prey) %.%\n      mutate(D_i = log(sum(Count^p))/p,\n             D_ik = log(sum(Count^p) - Count^p)/p) %.%\n      ungroup()\n  } else {\n    out <- data %.%\n      group_by(Prey) %.% \n      mutate(D_i = sum(Count^p)^(1/p), \n             D_ik = (sum(Count^p) - Count^p)^(1/p)) %.%\n      ungroup()\n  }\n  out$D_ik[is.infinite(out$D_ik)] <- NA\n  out$D_ik[out$D_ik == 0] <- NA\n  return(out)\n}\n\ndists <- compute_dist(data, 0.2, logtrans = FALSE)\nqplot(D_i, data = dists)\nqplot(D_ik, data = dists)\n\n#functions for returning weighted mean differences\n#input data set should be output data set from compute_dist()\n\nM1 <- function(data) {\n  out <- data %.%\n    group_by(Prey) %.%\n    summarise(M = mean(sd(D_ik) / mean(D_ik)))\n  out$M[is.infinite(out$M)] <- NA\n  return(out)\n}\n\nM2 <- function(data) {\n  out <- data %.%\n    group_by(Prey) %.%\n    summarise(M = mean((D_i - D_ik) / sd(D_ik)))\n  out$M[is.infinite(out$M)] <- NA\n  return(out)\n}\n\n#function to iterate over a sequence of selections for minkowski parameter p,\n#returning the mean distance difference \n\ndiffs_pseq <- function(data, pseq, logtrans = FALSE, f) {\n  extract_diffs <- function(p) {\n    tempdat <- compute_dist(data, p, logtrans)\n    out <- c(MeanDiff = mean(f(tempdat)$M, na.rm = TRUE),\n             MedDiff = median(f(tempdat)$M, na.rm = TRUE),\n             p = p)\n    return(out)\n  }\n  out <- t(sapply(pseq, extract_diffs))\n  return(tbl_df(data.frame(out)))\n}\npseq <- seq(from = 0.01, to = 0.5, by = 0.01)\n#diffs <- diffs_pseq(data, pseq, logtrans = FALSE, M2)\ndiffstest <- diffs_pseq(data2, pseq, logtrans = FALSE, M1)\nqplot(p, MeanDiff, data = diffstest, geom = c(\"point\", \"line\"))\nqplot(p, MeanDiff, data = diffs, geom = c(\"point\", \"line\"))\n\n#####PLOTS####\n# Multiple plot function\n#\n# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n# - cols:   Number of columns in layout\n# - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n#\n# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n# then plot 1 will go in the upper left, 2 will go in the upper right, and\n# 3 will go all the way across the bottom.\n#\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n  require(grid)\n  \n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n  \n  numPlots = length(plots)\n  \n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                     ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n  \n  if (numPlots==1) {\n    print(plots[[1]])\n    \n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n    \n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n      \n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n\n#function for producing ggplot object for plotting\n#histograms of the unaggregated scaled distance differences\n#based on sequence of p's. takes data input\n\ndisthist <- function(data, pseq, logtrans = FALSE, f) {\n  tempfunc <- function(p) {\n    tempdat <- f(compute_dist(data, p, logtrans))\n    singleplot <- qplot(log(M), data = tempdat, main = paste0(\"p = \", p),\n                        xlab = \"log(M_i)\")\n    return(singleplot)\n  }\n  out <- lapply(pseq, tempfunc)\n  return(out)\n}\npseq2 <- c(0.1, 0.2, 0.4, 0.6, 0.8)\nplots <- disthist(chen_all, pseq2, logtrans = FALSE, M2)\nmultiplot(plotlist = plots, cols = 2)\nrm(plots)\n\n####testing on HIPPO data####\nhippo <- tbl_df(read.table(\"~/Dropbox/School/Research/HIPPO/scores.txt\", \n                     header = TRUE, stringsAsFactors = FALSE))\nhippo <- hippo[,1:4]\npseq <- seq(from = 0.1, to = 0.8, by = 0.05)\nhipdiffs <- diffs_pseq(data, pseq, logtrans = FALSE, M2)\nqplot(p, MeanDiff, data = hipdiffs, geom = c(\"point\", \"line\"), \n      main = \"HIPPO M_i's\", ylab = \"Average M_i value\")\nplots <- disthist(hipdiffs, pseq2, logtrans = FALSE, M2)\nmultiplot(plotlist = plots, cols = 2)\nrm(plots)\n\n####Using Chen-new data (5.28.14)####\ndata2 <- tbl_df(read.csv(\"Chen-new.csv\", header = TRUE,\n                         stringsAsFactors = FALSE)) %.%\n  rename_col(\"reference\", \"Prey\") %.%\n  group_by(ExpNo, Prey) %.% \n  summarise(Count = sum(Total)) %.%\n  ungroup()\ndata2$Prey <- str_trim(data2$Prey)\n\ndiffs2 <- diffs_pseq(data2, pseq, logtrans = FALSE, M2)\nqplot(p, MeanDiff, data = diffs2, geom = c(\"point\", \"line\"),\n      ylab = \"Average M_i value\", main = \"p vs mean M_i\")\n\nscores  <- compute_scores(data2, 0.1) %.%\n  rename_col(\"Scores\", \"Scores01\") %.%\n  select(-MDist)\nscores$Scores02 <- compute_scores(data2, 0.2)$Scores\nscores$Scores03 <- compute_scores(data2, 0.3)$Scores\nscores$Scores04 <- compute_scores(data2, 0.4)$Scores\nscores$Scores06 <- compute_scores(data2, 0.6)$Scores\nscores$Scores08 <- compute_scores(data2, 0.8)$Scores\n\nwrite.csv(scores, \"scores_new.csv\", row.names = FALSE)\n\n####comparing to CRAPome####\ncrap <- tbl_df(read.csv(\"~/Dropbox/School/Research/HIPPO/CRAPome.csv\", \n                 header = TRUE, stringsAsFactors = FALSE)) \n        rename_col(\"GENE\", \"Prey\")\n\nscores <- left_join(scores, crap)\nscoressub <- subset(scores, Scores04 > 0.8)\nmean(scoressub$Frequency > 0.2)\nqplot(Scores04, Frequency, data = scoressub)\nsum(is.na(scores$Frequency))\n\n#removing 1's\npseq <- seq(from = 0.1, to = 0.6, by = 0.02)\ndatatest <- filter(data, Count > 4)\ndiffstest <- diffs_pseq(data, pseq, logtrans = FALSE, M1)\nqplot(p, MeanDiff, data = diffstest, geom = c(\"point\", \"line\"))\nqplot(p, MedDiff, data = diffstest, geom = c(\"point\", \"line\"))\n\n####calculating the M_i's using M1 function for chen1 and chen2####\nchen1 <- tbl_df(read.csv(\"Chen1.csv\", \n                         header = TRUE, stringsAsFactors = FALSE)) %.%\n  rename_col(\"SpectraC\", \"Count\") %.%\n  select(ExpNo:Count) %.%\n  apply_col(\"Prey\", str_trim) %.%\n  group_by(ExpNo, Prey) %.%\n  summarise(Count = sum(Count)) %.%\n  ungroup()\nchen2 <- tbl_df(read.csv(\"Chen2.csv\", \n                         header = TRUE, stringsAsFactors = FALSE)) %.% \n  select(-X) %.%\n  apply_col(\"Prey\", str_trim) %.%\n  group_by(ExpNo, Prey) %.%\n  summarise(Count = sum(Count)) %.%\n  ungroup()\nchen_all <- tbl_df(read.csv(\"~/Dropbox/School/Research/Minkowski/Chen-all.csv\", \n                            header = TRUE, stringsAsFactors = FALSE))\n\npseq <- seq(from = 0.05, to = 0.6, by = 0.025)\ndiffs1 <- diffs_pseq(chen1, pseq, logtrans = FALSE, M1)\ndiffs2 <- diffs_pseq(chen2, pseq, logtrans = FALSE, M1)\ndiffs_all <- diffs_pseq(chen_all, pseq, logtrans = FALSE, M2)\n\nqplot(p, MeanDiff, data = diffs1, geom = c(\"point\", \"line\"),\n      ylab = \"Average M_i value\", main = \"p vs mean M_i (Chen-1 data)\")\nqplot(p, MeanDiff, data = diffs2, geom = c(\"point\", \"line\"),\n      ylab = \"Average M_i value\", main = \"p vs mean M_i (Chen-2 data)\")\nqplot(p, MeanDiff, data = diffs_all[-1,], geom = c(\"point\", \"line\"),\n      ylab = \"Average M_i value\", main = \"p vs mean M_i (Chen-all data)\")\n\n####normalizing by length####\nrm(chen1, chen2, test)\npseq <- seq(from = 0.1, to = 0.6, by = 0.025)\nchen_norm <- chen_all\nchen_norm$Length[is.na(chen_norm$Length)] <- 300\nchen_norm$Count <- chen_norm$Count / chen_norm$Length\ndiffs_norm <- diffs_pseq(chen_norm, pseq, logtrans = FALSE, M2)\nqplot(p, MeanDiff, data = diffs_norm, geom = c(\"point\", \"line\"),\n      ylab = \"Average M_i value\", main = \"p vs mean M_i (normalized data)\")\ndists_norm <- compute_dist(chen_norm, 0.3, logtrans = FALSE)\n\n#scoring\n#takes length-normalized counts and normalizes by minkowski distance\n#data input should be output from compute_dist()\nscores <- mutate(dists_norm, Score = Count / D_i)\n",
    "created" : 1402070764953.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1153131416",
    "id" : "986A41E",
    "lastKnownWriteTime" : 1401911909,
    "path" : "~/Dropbox/School/Research/Minkowski/minkowski.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}